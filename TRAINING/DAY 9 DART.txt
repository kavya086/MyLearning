COLLECTIONS  -List  -Set  -Map  -RecordsConditional Operator Chaining//Use of conditional operator chainingvoid main(){  var a=10>5?"Hello":10<8?"Hi":"Bye";  print(a);  //prints "hello" since 10>5 is true  var b=10<5?"Hello":10>8?"Hi":"Bye";  print(b);  //prints "hi" since 10<5 is false, then 10>8 is true  var c=10<5?"Hello":10<8?"Hi":"Bye";  print(c); //prints "bye" since both are false}COLLECTIONS:In Dart, there are 3 types of collection data types are there. They are,1.List []2.Set  {}3.Map  {'key':'value'}All the elements in each collections must be of same DATA TYPE.LIST:List is an Ordered collection of elements enclosed in square brackets[] separated by commas, zero indexed and can have repeated elements.There are some inbuilt list methods too. Such as, length, reversed, isEmpty, remove(), add(), clear(), join(), toSet(), toString() etc...EXAMPLE:void main(){     var list=[1,2,3,4]; //by literal    List<int> list1=[1,2,3,4]; //the above statement is equivalent to this     List list2=List.empty(growable:true);    list2=[1,2,3,5];    print(list);    print(list1);    print(list[3]);    print(list1[2]);    print(list.length);    print(list.reversed);    print(list.isEmpty);    list.remove(3);    print(list);    list.add(3);    print(list);    print(list.join('+'));    print(list.toSet());    list.clear();    print(list); }OUTPUT:[1, 2, 3, 4][1, 2, 3, 4]434(4, 3, 2, 1)false[1, 2, 4][1, 2, 4, 3]1+2+4+3{1, 2, 4, 3}[]NULLABLITY:void main(){    var a=[1,null,3]; //nullable implicitly since var is used    var b=[3,2,...a,8];    print(b);}void main(){    List<int?> a=[1,null,3]; //explicitly given as nullable    List<int?> b=[3,2,...a,8];    print(b);}LIST OF LISTS:void main(){  List list=[[1],[2,3],[4,5,6]];  print(list.runtimeType);  List<List> list2=[[1],[2,3],[4,5,6]];  print(list2.runtimeType);}OUTPUT:List<dynamic>List<List<dynamic>>SET:Set is an unordered collection of elements enclosed in curly braces{} separated by commas, and cannot have repeated elements.There are some inbuilt set methods too. Such as, length, isEmpty, remove(), add(), clear(), join(), toList(), toString() etc...EXAMPLE:void main(){    var set1={1,2,3,4}; //by literal    Set<int> set2={1,2,3,4}; //the above statement is equivalent to this     Set set3=Set(); //by constructor    set3={1,2,3,5};        List <int> list=[1,2,3,4,4,4,4] //from list    Set sett=Set.from(list); //sett={1,2,3,4}    Set sett2=Set.of(list);    var x={} --> an empty map, not a set    print(set1);    print(set1.length);    print(set1.isEmpty);    set1.remove(3);    print(set1);    set1.add(3);    print(set1);    print(set1.join('+'));    print(set1.toList());    set1.clear();    print(set1);}OUTPUT:{1, 2, 3, 4}4false{1, 2, 4}{1, 2, 4, 3}1+2+4+3[1, 2, 4, 3]{}NULLABLITY:void main(){    var a={1,null,3}; //nullable implicitly since var is used    var b={3,2,...a,8};    print(b);}void main(){    Set<int?> a={1,null,3}; //explicitly given as nullable    Set<int?> b={3,2,...a,8};    print(b);}HASHSET, LINKEDHASHSET (Default), SPLAYTREESET :import 'dart:collection'; // For LinkedHashSet and SplayTreeSetimport 'dart:math';       // For generating random numbersvoid main() {  // Using HashSet - unordered, fast insertion and lookup  HashSet Hs = HashSet();  var stopwatch = Stopwatch()..start(); // Start measuring time  var random = List.generate(1000000, (_) => Random().nextInt(1000000)); // Generate 1M random integers  for (var i = 0; i < 1000000; i++) {    Hs.add(random[i]); // Insert into HashSet  }  stopwatch.stop(); //Stops measuring time  var elapse = stopwatch.elapsed.inMilliseconds; //give the inbetween time  print("$elapse ms");  // Using default Set (actually LinkedHashSet in Dart)  Set set = Set();  var stopwatch2 = Stopwatch()..start(); // Start timing  var random2 = List.generate(1000000, (_) => Random().nextInt(1000000)); // Generate 1M random numbers  for (var i = 0; i < 1000000; i++) {    set.add(random2[i]); // Insert into Set  }  stopwatch2.stop();  var elapse2 = stopwatch2.elapsed.inMilliseconds;  print("$elapse2 ms");  // Using LinkedHashSet - insertion order is preserved  LinkedHashSet LHS = LinkedHashSet();  var stopwatch3 = Stopwatch()..start(); // Start timing  var random3 = List.generate(1000000, (_) => Random().nextInt(1000000)); // Generate 1M random numbers  for (var i = 0; i < 1000000; i++) {    LHS.add(random3[i]); // Insert into LinkedHashSet  }  stopwatch3.stop();  var elapse3 = stopwatch3.elapsed.inMilliseconds;  print("$elapse3 ms");  // Using SplayTreeSet - keeps elements sorted, so insertion is slower due to sorting overhead  SplayTreeSet STS = SplayTreeSet();  var stopwatch4 = Stopwatch()..start(); // Start timing  var random4 = List.generate(1000000, (_) => Random().nextInt(1000000)); // Generate 1M random numbers  for (var i = 0; i < 1000000; i++) {    STS.add(random4[i]); // Insert into SplayTreeSet (sorted)  }  stopwatch4.stop();  var elapse4 = stopwatch4.elapsed.inMilliseconds;  print("$elapse4 ms");}OUTPUT:112 ms80 ms76 ms881 msMAP:Map is a ordered key-value paired collection data type enclosed in curly braces {'key':'value'}.The key must be unique, but values can be duplicated.The values are accessed by using the keys.There are some inbuilt set methods too. Such as, length, isEmpty, remove(), clear(),keys, values etc...EXAMPLE:void main(){  var map={'key1':'value1','key2':'value2','key3':'value3'}; //by literal   Map<String,String> map2={'key1':'value1','key2':'value2','key3':'value3'}; //the above statement is equivalent to this   Map map3=Map(); //by constructor  map3={'key1':'value1','key2':'value2','key3':'value3'};   print(map);  print(map2);  print(map3);  map.remove('key2');  print(map['key2']);  print(map.length);  map['key2']='NO VALUE';  print(map['key2']);  print('KEYS: ${map.keys}');  print('VALUES: ${map.values}');}OUTPUT:{key1: value1, key2: value2, key3: value3}{key1: value1, key2: value2, key3: value3}{key1: value1, key2: value2, key3: value3}null3NO VALUEKEYS: (key1, key2, key3)VALUES: (value1, NO VALUE, value3)NULLABILITY:void main(){    var a={1:"first",2:null,3:"third"}; //nullable implicitly since var is used    var b={4:"fourth",...a,8:"eighth"};    print(b);}void main(){    Map<int,String?> a={1:"first",2:null,3:"third"}; //explicitly given as nullable    Map<int,String?> b={4:"fourth",...a,5:"fifth"};    print(b);}EXAMPLE:void main(){  var map=[MapEntry("Five", 5), MapEntry("six",6), MapEntry("eight",8)];  print(map.runtimeType);  var map2={MapEntry("Five", 5), MapEntry("six",6), MapEntry("eight",8)};  print(map2.runtimeType);  var map3=Map.fromEntries(map);  print(map3.runtimeType);  print(map3);}OUTPUT:List<MapEntry<String, int>>_Set<MapEntry<String, int>>_Map<String, int>{Five: 5, six: 6, eight: 8}unmodifiable:void main() {  final set = Set.unmodifiable([1, 2, 3]);  print('Unmodifiable Set: $set');  final map = Map.unmodifiable({    'name': 'Dart',    'version': 3.9,  });  print('Unmodifiable Map: $map');}OUTPUT:Unmodifiable Set: {1,2,3}Unmodifiable Map: {'name': 'Dart', 'version': 3.9,}RECORDS:Record is also similar to collection datatype similar to tuple in python.All the elements in each collections can be of any DATA TYPE.IMMUTABLE.Accessed by position or keys using $ symbol or just the key.Eg: var record=("hello",10,20,greeting:"hi");Here, record.$1 -> hello      record.$2 -> 10      record.$3 -> 20      record.greeting ->hiEXAMPLE-1:void main(){  var rec=(greeting1:"HELLO",greeting2:"HI",1,2,3,true);  print(rec);  print(rec.runtimeType);  print(rec.$1);  print(rec.$2);  print(rec.$3);  print(rec.$4);  //rec.$4=5; - ERROR Records are immutable  print(rec.greeting1);  print(rec.greeting2);  print(rec.hashCode);  print(rec.toString());}OUTPUT:(1, 2, 3, true, greeting1: HELLO, greeting2: HI)(int, int, int, bool, {String greeting1, String greeting2})123trueHELLOHI375637527(1, 2, 3, true, greeting1: HELLO, greeting2: HI)EXAMPLE-2:void main(){  var (name,age)=("Kavya", 21); //Records can also be defined this way  print(name);  print(age);   print(display(name,age));}(String,int) display(name,age) //takes name and age as input and return it as a record{  return(name,age);}OUTPUT:Kavya21(Kavya, 21)Map and where Methods in List and Set:EXAMPLE-1:void main(){  var Names=["kavya","divya","bavya","gavya"];  var nam=Names.map(makeCaps);  print(nam);  var namee=Names.map((s)=>s[0].toUpperCase()+s.substring(1));  print(namee.toList());}String makeCaps(String s){  return s[0].toUpperCase()+s.substring(1);}OUTPUT:("Kavya","Divya","Bavya","Gavya")["Kavya","Divya","Bavya","Gavya"]EXAMPLE-2:void main(){  List<int> l=[3,6,9,12];  var li=l.map(square);  print(li.toList());    var le=l.map((i)=>i*i);  print(le.toList());  }  int square(int n)  {   return n*n;  } OUTPUT:[9,36,81,144][9,36,81,144]EXAMPLE-3:void main(){  var integ=[1,2,3,4,5,6];  var integ2=integ.map((i)=>integfunc(i,100));  print(integ2);}int integfunc(inte, integ){  return inte+integ;}OUTPUT:(101, 102, 103, 104, 105, 106)EXAMPLE-4:void main(){  List li=[1,2,3,4,5,6,7,8,9];  var l=li.where((i)=>(i<5));  print(l); }OUTPUT:(1,2,3,4)